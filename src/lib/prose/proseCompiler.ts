// src/lib/prose/proseCompiler.ts
import { createHash } from "node:crypto";

export const COMPILER_VERSION = "prose-compiler@0.2.0";

function sha256Hex(s: string) {
  return createHash("sha256").update(s).digest("hex");
}

function stableStringify(v: any): string {
  if (v === null || typeof v !== "object") return JSON.stringify(v);
  if (Array.isArray(v)) return `[${v.map(stableStringify).join(",")}]`;
  const keys = Object.keys(v).sort();
  return `{${keys.map((k) => JSON.stringify(k) + ":" + stableStringify(v[k])).join(",")}}`;
}

export type ReviewNote = {
  id: string;
  createdAt: string;
  authorUserId: string | null;
  targetType: string;
  targetId: string | null;
  body: string;
  runId: string;
};

export type ExecutionSpec = {
  tools?: Array<{ name: string; description?: string; input_schema?: any }>;
  mcpServers?: Record<string, any>;
  allowedTools?: string[];
  disallowedTools?: string[];
  permissionMode?: "default" | "acceptEdits" | "bypassPermissions" | string;
  enableToolSearch?: string;
  env?: Record<string, string>;
  limits?: { wallClockMs?: number; maxFileBytes?: number; maxArtifactBytes?: number };
};

export type CompileInput =
  | {
      kind: "task";
      task: {
        id: string;
        title: string;
        description: string;
        deliverablesSpec: any[];
        contextSpec: any[];
        mountsSpec: any[];
      };
      // ✅ evolving layer
      reviewNotes?: ReviewNote[];
      // ✅ optionally let tooling policy influence compilation
      executionSpec?: ExecutionSpec;
    }
  | {
      kind: "workflow_version";
      workflowVersion: {
        id: string;
        workflowId: string;
        version: number;
        definition: any;
      };
      reviewNotes?: ReviewNote[];
      executionSpec?: ExecutionSpec;
    };

export type CompileResult = {
  compilerVersion: string;
  sourceHash: string;
  programText: string;
  programHash: string;
  compilerInputsJson: string;
};

function renderReviewBlock(notes?: ReviewNote[]) {
  const arr = (notes ?? []).slice(0, 200); // hard cap for safety
  if (!arr.length) return "";
  const lines = arr.map((n) => `- (${n.createdAt}) ${n.body.replace(/\s+/g, " ").trim()}`);
  return `\n# review_notes\n${lines.join("\n")}\n`;
}

export function compileToProse(input: CompileInput): CompileResult {
  // ✅ canonical compiler inputs (this is what sourceHash covers)
  const canonical = (() => {
    if (input.kind === "task") {
      const t = input.task;
      return {
        kind: "task",
        id: t.id,
        title: t.title,
        description: t.description ?? "",
        deliverablesSpec: t.deliverablesSpec ?? [],
        contextSpec: t.contextSpec ?? [],
        mountsSpec: t.mountsSpec ?? [],
        reviewNotes: input.reviewNotes ?? [],
        executionSpec: input.executionSpec ?? null,
      };
    }
    const w = input.workflowVersion;
    return {
      kind: "workflow_version",
      id: w.id,
      workflowId: w.workflowId,
      version: w.version,
      definition: w.definition ?? {},
      reviewNotes: input.reviewNotes ?? [],
      executionSpec: input.executionSpec ?? null,
    };
  })();

  const compilerInputsJson = stableStringify(canonical);
  const sourceHash = sha256Hex(compilerInputsJson);

  // ✅ deterministic program emitter
  // For v0, we incorporate review notes as comments in program text (so it influences programHash).
  // Later you can translate review notes into actual structured Prose controls.
  const reviewBlock = renderReviewBlock(input.reviewNotes);

  const programText =
`# generated by ${COMPILER_VERSION}
# source_hash: ${sourceHash}
${reviewBlock}
agent captain:
  model: sonnet
  prompt: "You coordinate the run and produce a final result binding."

# v0 starter program (deterministic)
session "Collect context + constraints"
session "Execute task plan"
output result = session "Write deliverables + finalize"
`;

  const programHash = sha256Hex(programText);

  return {
    compilerVersion: COMPILER_VERSION,
    sourceHash,
    programText,
    programHash,
    compilerInputsJson,
  };
}